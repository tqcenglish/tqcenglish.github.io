<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>羚羊挂角</title>
  <icon>https://www.gravatar.com/avatar/912e82737b4a4cbf97e7625012e693f3</icon>
  <subtitle>无迹可寻</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tqcenglish.github.io/"/>
  <updated>2020-03-17T12:16:37.002Z</updated>
  <id>https://tqcenglish.github.io/</id>
  
  <author>
    <name>tqcenglish</name>
    <email>xx@example.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://tqcenglish.github.io/2020/03/16/Node-JavaScript/"/>
    <id>https://tqcenglish.github.io/2020/03/16/Node-JavaScript/</id>
    <published>2020-03-16T13:20:21.083Z</published>
    <updated>2020-03-17T12:16:37.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>通过 object.keys() 可以容易将 map 的键构建一个新的数组。在循环中可以避免调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasOwnProperty()</span><br></pre></td></tr></table></figure></p><p>判断是否是当前对象的属性。</p><h2 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h2><p>var 没有块作用域限制，对变量的声明周期容易困惑。<br><strong>坚持使用新关键字声明变量</strong></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li>对 this 的处理更好</li></ul><h2 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h2><p>使用模版字符串可以更容易的拼接需要的字符串格式。</p><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><p>参数使用 … 传递，可以在函数内部得到一个参数数组。<br>也可以在传递参数时通过 … 解开参数</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>通过关键字 class 在原型基础上实现 oo。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;h2 id=&quot;Object-keys&quot;&gt;&lt;a href=&quot;#Object-key
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sails</title>
    <link href="https://tqcenglish.github.io/2020/03/16/Node-Sails-Policies/"/>
    <id>https://tqcenglish.github.io/2020/03/16/Node-Sails-Policies/</id>
    <published>2020-03-16T13:20:21.080Z</published>
    <updated>2020-03-17T12:17:28.653Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.sailsjs.org/#!/documentation/concepts/Policies" target="_blank" rel="noopener">原文链接</a></p><h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>Policies在Sails中作为授权和访问控制的通用工具.它让你可以去在粒度基本上控制允许或拒绝访问你的控制器。例如，如果你建立了一个Dropbox,在让用户上传文件到文件夹前，你需要检查用户是否认证，是否有写文件的权限，最后你要去检查用户上传内容的文件夹是否有足够的空间。</p><p>Policies可以用于任何方面:HTTP基本认证,第三方程序单点登录， OAuth 2.0, 自定义授权/认证方案。</p><p><strong>Policies只能用于控制器而不能用于视图。如果你在routes.js配置文件中定义了一个路由去直接指向视图，将没有Policies会起作用。为了确信policies是可用的，你可以定义一个控制器去显示试图并在路由中配置action</strong></p><h2 id="实现你的第一个Policy"><a href="#实现你的第一个Policy" class="headerlink" title="实现你的第一个Policy"></a>实现你的第一个Policy</h2><p>Policies是定义在你的Sails程序的api/policies文件夹下的文件。每一个policy文件应该包含一个函数。</p><p>当运行时，policies是在控制器前运行的中间件功能。你可以将中间件串联在一起使用,这也是被设计为这样使用。每一个中间件应该只完成一个功能。</p><p>例如，象上面提到的可写权限策略。</p><p>  //policies/canWrite.js<br>  module.exports = function canWrite (req, res, next){<br>  var targetFolderId = req.param(‘id’);<br>  var userId = req.session.user.id;<br>  Permission<br>  .findOneByFolderId(targetFolderId)<br>  .exec( function foundPermission (err, permission) {<br>    //Unexpected error occurred – skip to the app’s default error(500) handler<br>    if(err) return next(err);<br>    //No permission exists linking this user to this folder. Maybe they got removed from it? Maybe they never had permission in the first place? Who cares?<br>    if(!permission) return res.redirect(‘/notAllowed’);<br>    //Ok, so a permission was found. Let’s be sure it’s a  “write”<br>    if(permission.type !== ‘write’) return res.redirect(‘/notAllowed’);<br>    //If we made it all the awy down here, looks like everything’s ok. so we’ll let the user through<br>    next();<br>    });<br>  };</p><p>##用Policies去保护控制器<br>Sails有内建一个ACL(访问控制表)位于config/policies.js文件。这个文件用于映射policies到你的控制器。</p><p>这个文件是声明，它描述了你的应用权限应该是什么，并不描述它是如何实现。这使得新开发者更容易的去理解发生了什么事。另外让你的应用更灵活因为你的要求是不可避免的不断改变。</p><p>你的config/policies.js文件应该导出一个Javascript对象，它的键名是控制器的名称(或’*’用于全部的policies).它的值是对象映射的操作名称和一个或多个policies.看下面获取更详细的说明和例子说明。</p><p>###应用一个policy到指定的控制器操作</p><p>  {<br>    ProfileController:{<br>      //Apply the ‘isLoggedIn’ policy to the ‘edit’ action of ‘ProfileController’<br>      edit:’isLoggedIn’<br>      //Apply the ‘isAdmin’ And ‘isLoggedIn’ policies , in the order, to the ‘create’ action<br>      create:[isAdmin’, ‘isLoggedIn’]<br>    }</p><p>  }</p><p>###应用一个policy到整个控制器</p><p>  {<br>    ProfileController:{<br>    //Apply ‘isLogged’ in by default to all actions that are Not specied below<br>    ‘*’: ‘isLoggedIn’,<br>    //If an action is explicitly listed, its policy list will override the default list<br>    //So, we have to list ‘isLoggedIn’ again for the ‘edit’ action if we want it to be applied<br>    edit: [‘isAdmin’, ‘isLoggedIn’]<br>  }</p><p><strong>默认的策略映射不会”cascade”或”trickle down”, 对于控制器的操作指定的策略映射会覆盖默认的映射</strong></p><blockquote><p>这是一般 Sails 关于权限控制的官方文档翻译。 后面再说吧。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.sailsjs.org/#!/documentation/concepts/Policies&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;提要&quot;&gt;&lt;a href=&quot;#提要&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="https://tqcenglish.github.io/2020/03/16/Vue-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    <id>https://tqcenglish.github.io/2020/03/16/Vue-进程-线程/</id>
    <published>2020-03-16T13:20:21.069Z</published>
    <updated>2020-03-17T12:18:16.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁发生在一个服务器和客服端同时向一个连接读或写</p><ul><li>send 和 recv交叉进行</li><li>连续send发送的数据不能太大</li><li>多线程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程-线程&quot;&gt;&lt;a href=&quot;#进程-线程&quot; class=&quot;headerlink&quot; title=&quot;进程/线程&quot;&gt;&lt;/a&gt;进程/线程&lt;/h1&gt;&lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP IP</title>
    <link href="https://tqcenglish.github.io/2020/03/16/Vue-TCP-IP/"/>
    <id>https://tqcenglish.github.io/2020/03/16/Vue-TCP-IP/</id>
    <published>2020-03-16T13:20:21.068Z</published>
    <updated>2020-03-17T12:17:50.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><h2 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h2><p>Internet是在一些共享的线路上发送数据，为实现共享，TCP是通过把需要发送的数据流分解为很多的小信息包在Internet上传输,而这些信息包在接受者的地方会再次重新合成在一起，因为信息包很小，会用很少的时间发送数据，从而其他程序的信息包可以同时传送。</p><h3 id="寻址-每个TCP连接的端点是由一个IP地址和一个端口号来唯一标识的。"><a href="#寻址-每个TCP连接的端点是由一个IP地址和一个端口号来唯一标识的。" class="headerlink" title="寻址:每个TCP连接的端点是由一个IP地址和一个端口号来唯一标识的。"></a>寻址:每个TCP连接的端点是由一个IP地址和一个端口号来唯一标识的。</h3><p>TCP是可靠的协议，通过几个规则来实现：</p><ul><li>防止数据在传输过程中被损坏， 每个信息包都包含一个校验码.</li><li>防止信息包丢失，TCP会要求接受方每收到一个信息包都要反馈一下， 否则自动重发。</li><li>防止信息包重复和顺序出错，TCP每传送一个信息不都会传送一个序号。</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在Internet上负责接收信息包并决定如何把他们传送到目的地的设备叫路由器。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>SSL,TLS。SSL是在TCP上连接的，与程序代码混合在一起。提供服务器的认证，加密，数据完整性。TLS只包含在协议堆栈中。</p><h3 id="S-C"><a href="#S-C" class="headerlink" title="S/C"></a>S/C</h3><p>客服端总是最开始连接的一端，服务器是等待客服端连接的一端</p><h3 id="端口列表"><a href="#端口列表" class="headerlink" title="端口列表"></a>端口列表</h3><p>/etc/services, 最大端口：65535， Linux系统请求小于1024的端口需要root</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>只保证收到的数据是完整的，不保证数据是否收到，是否只有一次， 次序是否一致。UDP长用在向服务器申请一个bite的数据,如果没有收到就继续申请。（DNS系统， 音频， 视频， 网络文件系统）.UDP限制一个信息包不能超过64ＫＢ.</p><p>软件通过检查源计算机和目的计算机的ＩＰ地址的头几位判断是本地还是远程。<br>服务器需要通过事先知道的端口来监听连接， 当客服端发起连接时，它的操作系统会选择一个事先不知道的端口号建立socket需要两部：</p><p>1.建立一个socket对象,通信类型(IPv4, IPv6, IPX/SPX, AFP)和协议家族(定义数据如何传输， SOCK_STREAM, SOCK_DGRAM)例如：s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)   ipv4,tcp</p><p>2.连接到远程的服务器上s.connect((‘<a href="http://www.example.com&#39;" target="_blank" rel="noopener">www.example.com&#39;</a>, 80))    need a tuple<br>    C语言的connect()函数需要远程机器的ip地址， Python会利用DNS把域名自动的转换为IP地址<br>    Python的socket库包含一个getservbyname()的函数， 他可以自动查询,需要两个参数端口名和协议名</p><pre><code>port = socket.getservbyname(&apos;ftp&apos;,&apos;tcp&apos;)socketIml.getsockname() 得到本身的ip地址和端口号socketIml.getpeername()    得到远程的ip地址和端口号</code></pre><h3 id="socket对象和文件对象的比较"><a href="#socket对象和文件对象的比较" class="headerlink" title="socket对象和文件对象的比较"></a>socket对象和文件对象的比较</h3><ul><li>socket对象:读写数据时，需要协议可以详细地控制，使用二进制协议传送固定大小数据，数据超时需要处理，ＵＤＰ</li><li>文件对象: 面向线性的协议，一般只对TCP连接工作很好</li></ul><p>数据只有在调用了shutdown()函数后才能确保被发送,创建文件对象时如果指定了缓冲区，就需要调用flush(),即使有了文件对象也要保存socket对象，shutdown()只有socket对象才有.不同协议(TCP,UDP)可以使用相同的端口. recvfrom()调用返回一个tuple, 包括接受的数据和发送数据的地址,一个服务器进程终止后，操作系统会保留几分钟他的端口，防止其他的进程在超时前使用这个端口。</p><p>SO_REUSEADDR为true,会立刻释放端口不同平台的Pytho支持的socket选项不同。通过dir(socket)查看bind()第一个参数为空，表示绑定所有的接口和地址syslog优先权</p><pre><code>LOG_EMERG 紧急情况，系统非正常关机或不能用LOG_ALERT 向管理员发送警报LOG_CRIT  产生了一个致命错误LOG_ERR      产生了一个普通错误LOG_WARNING 一个警告LOG_NOTICE 重要的正常通知LOG_INFO 普通信息L0G_DEBUG 调试信息</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h1&gt;&lt;h2 id=&quot;TCP基础&quot;&gt;&lt;a href=&quot;#TCP基础&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>File</title>
    <link href="https://tqcenglish.github.io/2020/03/16/%E5%85%B6%E4%BB%96-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81/"/>
    <id>https://tqcenglish.github.io/2020/03/16/其他-文件传送/</id>
    <published>2020-03-16T13:20:21.058Z</published>
    <updated>2020-03-17T12:19:47.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件传送"><a href="#文件传送" class="headerlink" title="文件传送"></a>文件传送</h1><p>在多台电脑直接文件传送的方式主要包括移动存储和网络.由于 fat32 格式的限制不能存储超过 4g 的文件，当需要在两台电脑直接进行复制时有两种方式.</p><ol><li>对移动存储格式化为非 fat32 的格式.</li><li>通过局域网络传送.</li></ol><h2 id="局域网文件传送"><a href="#局域网文件传送" class="headerlink" title="局域网文件传送"></a>局域网文件传送</h2><p>将多台电脑连接在相同的局域网是一件简单的事情, 然后对于传送软件可以有如下选择:</p><ol><li>scp 主要针对 Linux 系统.</li><li>建立一个简单的 Http 服务器, 然后通过网络打开对应页面后进行下载. 对于不同的编程语言大多有一句命令实现 http 服务器的方式。 Node.js 可以直接通过如下命令安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-server -g</span><br></pre></td></tr></table></figure><p>然后运行到需要下载的页面运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server</span><br></pre></td></tr></table></figure><p>就可以了。</p><ol start="3"><li>利用 QQ 等其它软件.<a href="https://github.com/RobinLinus/snapdrop" target="_blank" rel="noopener">snapdrop</a> 是一种类似 AirDrop 的局域网传送,不需要安装任何软件。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件传送&quot;&gt;&lt;a href=&quot;#文件传送&quot; class=&quot;headerlink&quot; title=&quot;文件传送&quot;&gt;&lt;/a&gt;文件传送&lt;/h1&gt;&lt;p&gt;在多台电脑直接文件传送的方式主要包括移动存储和网络.由于 fat32 格式的限制不能存储超过 4g 的文件，当需要在两台电脑
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tqcenglish.github.io/2020/03/16/%E5%85%B6%E4%BB%96-http-XSS/"/>
    <id>https://tqcenglish.github.io/2020/03/16/其他-http-XSS/</id>
    <published>2020-03-16T13:20:21.043Z</published>
    <updated>2020-03-16T13:48:45.532Z</updated>
    
    <content type="html"><![CDATA[<p>title:XSS<br>date:2018-09-26<br>tags:http, xss</p><hr><p>XSS，即 Cross Site Script，中译是跨站脚本攻击。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">跨站脚本攻击(Cross-site scripting)</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html" target="_blank" rel="noopener">CSRF 攻击的应对之道</a></li><li><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">浅说 XSS 和 CSRF</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title:XSS&lt;br&gt;date:2018-09-26&lt;br&gt;tags:http, xss&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;XSS，即 Cross Site Script，中译是跨站脚本攻击。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.moz
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DNS</title>
    <link href="https://tqcenglish.github.io/2020/03/16/%E5%85%B6%E4%BB%96-DNS/"/>
    <id>https://tqcenglish.github.io/2020/03/16/其他-DNS/</id>
    <published>2020-03-16T13:20:21.031Z</published>
    <updated>2020-03-17T12:19:19.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><ul><li>DNS是一个全球分布式数据库</li><li>操作系统先查询/etc/hosts/， 然后去DNS查询</li><li>操作系统提供一个方法为名称服务器(DNS服务器)指定IP地址  /etc/resolv.conf</li><li>Python定义socket.getaddrinfo()返回一个tuple的list, 根据所支持的不同协议产生一个结果<br>  host is a simple utility for performing DNS lookups 对于一个IP地址，完全可能不存在反向的映射。反向查找时需要捕获socket.herror()异常,反向查询存在欺骗，由于ＤＮＳ信息的授权方式，反向查询的授权是基于ＩＰ地址的.先反向再正向，确定结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DNS是一个全球分布式数据库&lt;/li&gt;
&lt;li&gt;操作系统先查询/etc/hosts/， 然后去DNS查询&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# 语法</title>
    <link href="https://tqcenglish.github.io/2020/03/16/%E5%85%B6%E4%BB%96-C-%E8%AF%AD%E6%B3%95/"/>
    <id>https://tqcenglish.github.io/2020/03/16/其他-C-语法/</id>
    <published>2020-03-16T13:20:21.019Z</published>
    <updated>2020-03-16T13:20:21.019Z</updated>
    
    <content type="html"><![CDATA[<ul><li>文件名可以与类名称不同</li><li>MSDN 教程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;文件名可以与类名称不同&lt;/li&gt;
&lt;li&gt;MSDN 教程&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term=".Net C#" scheme="https://tqcenglish.github.io/tags/Net-C/"/>
    
  </entry>
  
  <entry>
    <title>TODO</title>
    <link href="https://tqcenglish.github.io/2018/10/23/%E5%85%B6%E4%BB%96-odoo/"/>
    <id>https://tqcenglish.github.io/2018/10/23/其他-odoo/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.056Z</updated>
    
    <content type="html"><![CDATA[<p>模仿网络教程 <a href="https://github.com/ruter/Odoo-Tutorial-Demo/tree/master/todo" target="_blank" rel="noopener">todo</a> 实现一个 odoo 模块。 并画图做详细描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;模仿网络教程 &lt;a href=&quot;https://github.com/ruter/Odoo-Tutorial-Demo/tree/master/todo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;todo&lt;/a&gt; 实现一个 odoo 模块。 并画图做详
      
    
    </summary>
    
    
      <category term="odoo" scheme="https://tqcenglish.github.io/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>REST</title>
    <link href="https://tqcenglish.github.io/2018/09/25/%E5%85%B6%E4%BB%96-http-REST/"/>
    <id>https://tqcenglish.github.io/2018/09/25/其他-http-REST/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.045Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jasonGeng88/blog/blob/master/201706/rest-api.md" target="_blank" rel="noopener">REST API URI 设计的七准则</a></p><p> <img src="REST.png" alt="rest"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/jasonGeng88/blog/blob/master/201706/rest-api.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;REST API URI 设计的七准则&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="rest" scheme="https://tqcenglish.github.io/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://tqcenglish.github.io/2018/09/25/%E5%85%B6%E4%BB%96-http-HTTP/"/>
    <id>https://tqcenglish.github.io/2018/09/25/其他-http-HTTP/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>http 协议基于 TCP, 是当前的互联网基石。</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201705/https.md" target="_blank" rel="noopener">基于此文</a>的理解图</p><p><img src="HTTP.png" alt="mindNode"></p><p><a href="https://legacy.gitbook.com/book/bagder/http2-explained/details" target="_blank" rel="noopener">http2 介绍</a><br><a href="https://github.com/bagder/http3-explained" target="_blank" rel="noopener">http3 介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;http 协议基于 TCP, 是当前的互联网基石。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jasonGeng88/blog/blob/master/201705/https.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="http" scheme="https://tqcenglish.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Pi 相关项目</title>
    <link href="https://tqcenglish.github.io/2018/09/19/%E5%85%B6%E4%BB%96-%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>https://tqcenglish.github.io/2018/09/19/其他-树莓派/</id>
    <published>2018-09-18T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.022Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派 硬件极客的选择，可以实现一些初步的想法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>树莓派通过官方网站下载镜像文件，然后通过 DD 命令或其他工具写入 SD 卡。 这里包含两个重要步骤</p><ul><li>设置 wifi 密码</li><li>开启 ssh 登录</li></ul><p>设置 wifi ssh <a href="http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html" target="_blank" rel="noopener">无屏幕和键盘配置树莓派WiFi和SSH</a>sss<br><a href="https://github.com/mozilla-iot/wiki/wiki/Setting-up-Raspberry-Pi" target="_blank" rel="noopener">Setting-up-Raspberry-Pi</a></p><p>不然都把设备插上电源不能远程访问控制还是很崩溃吧。</p><h2 id="有趣的项目"><a href="#有趣的项目" class="headerlink" title="有趣的项目"></a>有趣的项目</h2><ul><li><a href="http://dingdang.hahack.com/" target="_blank" rel="noopener">对话机器人</a></li><li><a href="http://shumeipai.nxez.com/2018/08/12/facial-recognition-identification-on-raspberry-pi.html" target="_blank" rel="noopener">在树莓派上实现人脸识别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树莓派 硬件极客的选择，可以实现一些初步的想法。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;树莓派通过官方网站下载镜像文件，然后通过 DD 命令或其他工具写入 SD 卡
      
    
    </summary>
    
    
      <category term="pi" scheme="https://tqcenglish.github.io/tags/pi/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://tqcenglish.github.io/2018/09/18/Vue-%E9%97%AD%E5%8C%85/"/>
    <id>https://tqcenglish.github.io/2018/09/18/Vue-闭包/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.067Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html" target="_blank" rel="noopener">闭包</a> golang 闭包访问局部变量会导致局部变量变为堆分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;闭包&lt;/a&gt; golang 闭包访问局部变量会导致局部变量变
      
    
    </summary>
    
    
      <category term="golang" scheme="https://tqcenglish.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发</title>
    <link href="https://tqcenglish.github.io/2018/09/16/%E5%85%B6%E4%BB%96-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://tqcenglish.github.io/2018/09/16/其他-小程序开发/</id>
    <published>2018-09-15T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.022Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序开发， 基于微信强太的生态。 小程序的开发价值显而易见。 小程序开发资源</p><ul><li><a href="https://mp.weixin.qq.com/cgi-bin/wx" target="_blank" rel="noopener">小程序</a></li><li><a href="https://tencent.github.io/wepy/document.html#/" target="_blank" rel="noopener">wepy</a></li></ul><p>小程序可以注册个人账号，不认证的情况下可以体验开发流程。</p><p>调试模式不会对服务器进行验证，线上模式需要。 最好备案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微信小程序开发， 基于微信强太的生态。 小程序的开发价值显而易见。 小程序开发资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/cgi-bin/wx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小程序&lt;/
      
    
    </summary>
    
    
      <category term="mini program" scheme="https://tqcenglish.github.io/tags/mini-program/"/>
    
  </entry>
  
  <entry>
    <title>后端程序员面试题</title>
    <link href="https://tqcenglish.github.io/2018/09/15/Node-%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://tqcenglish.github.io/2018/09/15/Node-后端程序员面试题/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.080Z</updated>
    
    <content type="html"><![CDATA[<p>  后端开发面试题 <a href="https://github.com/monklof/Back-End-Developer-Interview-Questions#general" target="_blank" rel="noopener">Back-End-Developer-Interview-Questions</a> 包含了面试中的常见问题，先做个小抄吧. <a href="http://xargin.com/backend-engineer-interview/" target="_blank" rel="noopener">一个不完全的回答</a></p><h2 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h2><ul><li><p>语言设计中空引用(null reference)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？</p><p>在 C, Java, go, Js 中使用 <strong>空引用</strong> 对应会出现 断错误, nullpointer Exception, panic, undefined. 出现这些错误时如果没有对异常处理程序会终止工作。  在不同语言中移除的后果</p><ul><li>Js, 在数据初始化时必须制定数据，缺少灵活性。与其他语言对接时会缺少对应的语义。 例如 web 不传参数可以用 null 表示。</li></ul></li><li><p>封装的重要性体现在哪儿？<br>  通过封装可以屏蔽内部实现细节， 让业务开发逻辑清晰。 通用功能封装为模块可以反复使用。 一个成功的语言必然有对应成功的包管理器， 通过包管理引用封装好的模块即减少工作量又更稳定。</p></li><li><p>不变性(Immutability)是指: (变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助<br>  不同语言对不变的变量都有对应的关键字。 不变性可解决并发时的读写冲突问题。</p></li><li><p>在客户端渲染(client-side rendering)和服务端渲染(server-side rendering)之间，你是如何权衡的？<br>web 由原来的 jsp 发展到现在的前后端分离再到 next.js 框架的诞生。 客服端渲染由浏览器实现网页的显示。 主要包含了数据的读取等。 服务端渲染是在一个网页请求后 html 就生成完毕。 客服端渲染对客户的电脑配置要求更高，体验更好。 服务端渲染对 seo 更友好。并且加载更快。但是每一次访问都需要重复加载 js/css.</p></li><li><p>当你在浏览器地址栏输入google.com回车之后都发生了什么?<br>首先通过 dns 获取服务器 ip 地址，然后建立 tcp 连接。 在 tcp 连接上进行 http 协议通信。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  后端开发面试题 &lt;a href=&quot;https://github.com/monklof/Back-End-Developer-Interview-Questions#general&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Back-End-Dev
      
    
    </summary>
    
    
      <category term="面试" scheme="https://tqcenglish.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mongodb</title>
    <link href="https://tqcenglish.github.io/2018/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93-Mongodb/"/>
    <id>https://tqcenglish.github.io/2018/09/15/数据库-Mongodb/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.073Z</updated>
    
    <content type="html"><![CDATA[<p>mongo是一个面向文档的数据库，它集合了nosql和sql数据库两方面的特性。所有实体都是在首次使用时创建。</p><p>没有严格的事务特性，但是它保证任何一次数据变更都是原子性的。也没有固定的数据模型,mongo以javascript作为命令行执行引擎，所以利用shell进行复杂的计算和查询时会相当的慢。</p><p>mongo本身支持集群和数据分片, mongo是c++实现的，支持windows mac linux等主流操作系统. 性能优越，速度快</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mongo是一个面向文档的数据库，它集合了nosql和sql数据库两方面的特性。所有实体都是在首次使用时创建。&lt;/p&gt;
&lt;p&gt;没有严格的事务特性，但是它保证任何一次数据变更都是原子性的。也没有固定的数据模型,mongo以javascript作为命令行执行引擎，所以利用she
      
    
    </summary>
    
    
      <category term="database" scheme="https://tqcenglish.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="https://tqcenglish.github.io/2018/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    <id>https://tqcenglish.github.io/2018/09/15/数据库-Mysql/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.073Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 是免费的关系数据库。</p><h2 id="数据库使用的最佳方式"><a href="#数据库使用的最佳方式" class="headerlink" title="数据库使用的最佳方式"></a>数据库使用的最佳方式</h2><ul><li>尽量使用预处理.</li><li>多条记录操作使用批处理.</li><li>不使用外连接</li><li>使用 not exist 替换 not in</li><li>or 不能太多</li><li>更新操作放在事务最后</li><li>少用临时表</li><li>distinct 导致不必要的排序</li></ul><h2 id="数据库优化方式"><a href="#数据库优化方式" class="headerlink" title="数据库优化方式"></a>数据库优化方式</h2><ul><li>show status</li><li>explain</li><li>show profile</li><li>trace</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mysql 是免费的关系数据库。&lt;/p&gt;
&lt;h2 id=&quot;数据库使用的最佳方式&quot;&gt;&lt;a href=&quot;#数据库使用的最佳方式&quot; class=&quot;headerlink&quot; title=&quot;数据库使用的最佳方式&quot;&gt;&lt;/a&gt;数据库使用的最佳方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;尽量使用预处理.
      
    
    </summary>
    
    
      <category term="sql" scheme="https://tqcenglish.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>短网址</title>
    <link href="https://tqcenglish.github.io/2018/09/13/%E5%85%B6%E4%BB%96-%E7%9F%AD%E7%BD%91%E5%9D%80/"/>
    <id>https://tqcenglish.github.io/2018/09/13/其他-短网址/</id>
    <published>2018-09-12T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.053Z</updated>
    
    <content type="html"><![CDATA[<p>短网址指将长链接转换成易分享的短地址(6位左右)。 <a href="https://segmentfault.com/a/1190000012088345" target="_blank" rel="noopener">短网址(short URL)系统的原理及其实现</a></p><p>主要两种算法</p><ul><li>自增序列算法，将网址写入数据库，然后将记录id 通过 64 进制显示。</li><li>md5后取其中一部分的一系列算法。</li></ul><h2 id="开源实现"><a href="#开源实现" class="headerlink" title="开源实现"></a>开源实现</h2><ul><li><a href="https://github.com/prologic/shorturl" target="_blank" rel="noopener">shorturl</a> </li><li><a href="https://github.com/Youthink/short_url" target="_blank" rel="noopener">short_url</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;短网址指将长链接转换成易分享的短地址(6位左右)。 &lt;a href=&quot;https://segmentfault.com/a/1190000012088345&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;短网址(short URL)系统的原理及其实现&lt;/a
      
    
    </summary>
    
    
      <category term="net" scheme="https://tqcenglish.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透</title>
    <link href="https://tqcenglish.github.io/2018/09/12/%E5%85%B6%E4%BB%96-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://tqcenglish.github.io/2018/09/12/其他-内网穿透/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.052Z</updated>
    
    <content type="html"><![CDATA[<p>由于 ipv4 地址总量少， 当前互联网是多个用户使用一个局域网。 在接入公网时候才使用共同的一个公网 IP。 通过 NAT 可以解决 IP 地址稀少的问题。 但是对于在内网中架设 web 服务器需要非局域网用户访问时就需要内网穿透代理。</p><h2 id="内网穿透代理"><a href="#内网穿透代理" class="headerlink" title="内网穿透代理"></a>内网穿透代理</h2><p>当前主要有两种方式 </p><ol><li>通过 vpn 方式将管理设备放在一个局域网中。</li><li>通过 vps 建立中央代理， frp 使用的方式。 在 socket  上代理 http 协议。</li></ol><ul><li><a href="https://www.zerotier.com" target="_blank" rel="noopener">zerotier</a></li><li><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></li></ul><p>HTTP 内网穿透</p><h2 id="对内网穿透软件进行相关讨论"><a href="#对内网穿透软件进行相关讨论" class="headerlink" title="对内网穿透软件进行相关讨论"></a><a href="https://tkv.io/posts/picojs-intro/" target="_blank" rel="noopener">对内网穿透软件进行相关讨论</a></h2><ol><li>ngrok1.x 存在内存泄漏问题</li><li>localtunel 原理是客户端与服务端建立 socket 连接， 外部请求先到服务端，服务端从建立的 socket 将数据发送到客户端，最后客户端发送数据到绑定的端口。 golang 客户端与js  服务端之间存在不稳定（socket 自动就断了）。</li><li>推荐使用  frp</li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="http://einverne.github.io/post/2018/06/zerotier.html" target="_blank" rel="noopener">使用 Zerotier 组建虚拟局域网实现内网穿透</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于 ipv4 地址总量少， 当前互联网是多个用户使用一个局域网。 在接入公网时候才使用共同的一个公网 IP。 通过 NAT 可以解决 IP 地址稀少的问题。 但是对于在内网中架设 web 服务器需要非局域网用户访问时就需要内网穿透代理。&lt;/p&gt;
&lt;h2 id=&quot;内网穿透代
      
    
    </summary>
    
    
      <category term="proxy" scheme="https://tqcenglish.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC dial</title>
    <link href="https://tqcenglish.github.io/2018/09/11/%E5%85%B6%E4%BB%96-WebRTC-Dial/"/>
    <id>https://tqcenglish.github.io/2018/09/11/其他-WebRTC-Dial/</id>
    <published>2018-09-10T16:00:00.000Z</published>
    <updated>2020-03-16T13:20:21.029Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/vialer/vialer-js" target="_blank" rel="noopener">vialer-js 源码</a></li><li><a href="https://vialer-js.io" target="_blank" rel="noopener">vialer-js 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vialer/vialer-js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vialer-js 源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vialer-js.i
      
    
    </summary>
    
    
      <category term="webRTC" scheme="https://tqcenglish.github.io/tags/webRTC/"/>
    
  </entry>
  
</feed>
